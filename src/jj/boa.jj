/* @author Sambhav P. Srirama */

options
{
  JDK_VERSION = "1.6";
  JAVA_UNICODE_ESCAPE = true;
  STATIC = true;
}

PARSER_BEGIN(BoaParser)
package boa.parser;

import java.util.ArrayList;

import boa.compiler.ast.*;
import boa.compiler.ast.expressions.*;
import boa.compiler.ast.literals.*;
import boa.compiler.ast.statements.*;
import boa.compiler.ast.types.*;

public class BoaParser {
  public void setTabSize(final int size) {
    jj_input_stream.setTabSize(size);
  }
  public static void error_skipto(int kind, ParseException e) {
    System.out.println(e.toString());

    Token t;
    do {
      t = getNextToken();
    } while (t.kind != kind);
  }

  public static void error_skipto(int kind) {
    error_skipto(kind, generateParseException());
  }
}

PARSER_END(BoaParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN :
{
  < SINGLE_LINE_COMMENT : "#" ( ~["\n", "\r"] )* ( "\n"| "\r"| "\r\n" )? >
}

TOKEN :
{
  < DOLLAR : "$" >
| < SEMICOLON : ";" >
| < OF : "of" >
| < IF : "if" >
| < DO : "do" >
| < OR : "or" >
| < AND : "and" >
| < MAP : "map" >
| < STACK : "stack" >
| < SET : "set" >
| < FOR : "for" >
| < FOREACH : "foreach" >
| < IFALL : "ifall" >
| < EXISTS : "exists" >
| < NOT : "not" >
| < TYPE : "type" >
| < ELSE : "else" >
| < CASE : "case" >
| < OUTPUT : "output" >
| < FORMAT : "format" >
| < WHILE : "while" >
| < BREAK : "break" >
| < ARRAY : "array" >
| < STATIC : "static" >
| < SWITCH : "switch" >
| < RETURN : "return" >
| < WEIGHT : "weight" >
| < RESULT : "result" >
| < DEFAULT_ : "default" >
| < CONTINUE : "continue" >
| < FUNCTION : "function" >
| < VISITOR : "visitor" >
| < BEFORE : "before" >
| < AFTER : "after" >
| < WILDCARD : "_" >
| < STOP : "stop" >
}

TOKEN :
{
  < INTEGER_LITERAL : ( "-" )? ( <BINARY_LITERAL>| <OCTAL_LITERAL>| <DECIMAL_LITERAL>| <HEX_LITERAL> ) >
| < #BINARY_LITERAL : "0" ["b", "B"] ( ["0"-"1"] )+ >
| < #OCTAL_LITERAL : "0" ( ["0"-"7"] )* >
| < #DECIMAL_LITERAL : ["1"-"9"] ( <DIGIT> )* >
| < #HEX_LITERAL : "0" ["x", "X"] ( <HEX_DIGIT_LITERAL> )+ >
| < #HEX_DIGIT_LITERAL : ( <DIGIT>| ["a"-"f", "A"-"F"] ) >
| < FLOATING_POINT_LITERAL : ( "-" )? ( "." ( <DIGIT> )+ ( <EXPONENT> )?| ( <DIGIT> )+ <EXPONENT>| ( <DIGIT> )+ "." ( <DIGIT> )* ( <EXPONENT> )? ) >
| < #EXPONENT : ["e", "E"] ( ["+", "-"] )? ( <DIGIT> )+ >
| < CHARACTER_LITERAL : "'" ( ( ~["'", "\\", "\n", "\r"] )| ( "\\" ( ["n", "t", "b", "r", "f", "\\", "'", "\""]| ["0"-"7"] ( ["0"-"7"] )?| ["0"-"3"] ["0"-"7"] ["0"-"7"] ) ) ) "'" >
| < REGEX_LITERAL : "`" ( ~["`", "\n", "\r"] )* "`" >
| < STRING_LITERAL : "\"" ( ( ~["\"", "\\", "\n", "\r"] )| ( "\\" ( ["n", "t", "b", "r", "f", "\\", "'", "\""]| ["0"-"7"] ( ["0"-"7"] )?| ["0"-"3"] ["0"-"7"] ["0"-"7"] ) ) )* "\"" >
| < FINGERPRINT_LITERAL : <INTEGER_LITERAL> ["p", "P"] >
| < TIME_LITERAL : <INTEGER_LITERAL> ["t", "T"]| "T" <STRING_LITERAL> >
}

TOKEN :
{
  < IDENTIFIER : <LETTER> ( <LETTER>| <DIGIT>| "_" )* >
| < #LETTER : ["a"-"z", "A"-"Z"] >
| < #DIGIT : ["0"-"9"] >
}

Start Start() :
{
  Token end;
  Program program;
}
{
  program = Program()
  end = < EOF >
  { return new Start(program).setPositions(program, end); }
}

// Program ::= (Declaration | Statement)+
Program Program() :
{
  Program toReturn = new Program();
  Statement toAdd;
}
{
  (
    try {
      (
        LOOKAHEAD( Declaration() )
        toAdd = Declaration()
      |
        toAdd = Statement()
      )
      { toReturn.addStatement(toAdd); }
    } catch (ParseException e) {
      error_skipto(SEMICOLON, e);
    }
  )+
  { return toReturn.setPositions(toReturn.getStatement(0), toReturn.getStatement(toReturn.getStatementsSize() - 1)); }
}

// Declaration ::= VarDeclaration | StaticVarDeclaration | TypeDeclaration
Statement Declaration() :
{
  Statement toReturn;
}
{
  (
    toReturn = TypeDecl()
  |
    toReturn = StaticVarDecl()
  |
    toReturn = VarDecl()
  )
  { return toReturn; }
}

// TypeDecl = 'type' type_name 2'=' Type ';'.
// type_name = identifier.
TypeDecl TypeDecl() :
{
  Token start;
  Token end;
  Identifier typeName;
  AbstractType type;
}
{
  start = < TYPE >
  typeName = Identifier()
  "="
  type = Type()
  end = < SEMICOLON >

  { return new TypeDecl(typeName, type).setPositions(start, end); }
}

// StaticVarDecl = 'static' VarDecl.
VarDeclStatement StaticVarDecl() :
{
  Token start;
  VarDeclStatement varDecl;
}
{
  start = < STATIC >
  varDecl = VarDecl()
  { varDecl.setStatic(true); return varDecl.setStart(start); }
}

// VarDecl = var_name ':' [Type] ['=' Expression | Block] ';'.
// var_name = identifier.
VarDeclStatement VarDecl() :
{
  Token end;
  VarDeclStatement toReturn;
}
{
  toReturn = ForVarDecl()
  end = < SEMICOLON >
  { return toReturn.setEnd(end); }
}

// Type =
//   type_name | ArrayType | MapType | TupleType |
//   OutputType | FunctionType | VisitorType | StackType | SetType.
// type_name = identifier.
AbstractType Type() :
{
  AbstractType toReturn;
}
{
  (
    toReturn = Identifier()
  |
    toReturn = ArrayType()
  |
    toReturn = MapType()
  |
    toReturn = TupleType()
  |
    toReturn = OutputType()
  |
    toReturn = FunctionType()
  |
    toReturn = VisitorType()
  |
    toReturn = StackType()
  |
    toReturn = SetType()
  )
  { return toReturn; }
}

// Component = [component_name ':'] ComponentType.
// component_name = identifier.
// ComponentType = Type.
Component Component() :
{
  Identifier identifier = null;
  AbstractType type;
}
{
  [
    LOOKAHEAD( Identifier() ":" )
    identifier = Identifier()
    ":"
  ]
  type = Type()
  
  { return new Component(identifier, type).setPositions(identifier, type); }
}

// ArrayType = 'array' 'of' Element.
// Element = Component.
ArrayType ArrayType() :
{
  Token start;
  Component element;
}
{
  start = < ARRAY >
  < OF >
  element = Component()
  { return new ArrayType(element).setPositions(start, element); }
}

// TupleType = '{' [Member {"," Member} [","]] '}'.
TupleType TupleType() :
{
  Token start;
  Token end;
  TupleType toReturn = new TupleType();
  Component member;
}
{
  start = "{"
  [
    member = Member()
    { toReturn.addMember(member); }

    (
      LOOKAHEAD( "," Member() )
      ","
      member = Member()
      { toReturn.addMember(member); }
    )*

    [
      ","
    ]
  ]
  end = "}"
  { return toReturn.setPositions(start, end); }
}

// Member = TypeDecl | StaticVarDecl | Component.
Component Member() :
{
  Component toReturn = null;
}
{
  (
    TypeDecl()
  |
    StaticVarDecl()
  |
    toReturn = Component()
  )
  { return toReturn; }
}

// MapType = 'map' '[' Key ']' 'of' Value.
// Key = Component.
// Value = Component.
MapType MapType() :
{
  Token start;
  Component key;
  Component value;
}
{
  start = < MAP >
  "["
  key = Component()
  "]"
  < OF >
  value = Component()
  { return new MapType(key, value).setPositions(start, value); }
}

// StackType = 'stack' 'of' Value.
// Value = Component.
StackType StackType() :
{
  Token start;
  Component value;
}
{
  start = < STACK >
  < OF >
  value = Component()
  { return new StackType(value).setPositions(start, value); }
}

// SetType = 'set' 'of' Value.
// Value = Component.
SetType SetType() :
{
  Token start;
  Component value;
}
{
  start = < SET >
  < OF >
  value = Component()
  { return new SetType(value).setPositions(start, value); }
}

// OutputType = 'output' table_type [Parameter] {Index} 'of' Element [Weight] [FormatSpec].
// table_type = identifier.
// Parameter = '(' Expression ')'.
// Index = '[' Component ']'.
// Element = Component.
// Weight = 'weight' Component.
// FormatSpec = 'format' '(' ArgumentList ')'.
// ArgumentList = ExprList.
OutputType OutputType() :
{
  Token start;
  Token end;
  Token set;
  OutputType toReturn;
  Expression expression;
  Identifier tableType;
  Component type;
  Component index;
  Component weight;
}
{
  start = < OUTPUT >
  (
    tableType = Identifier()
  |
    set = < SET >
    { tableType = new Identifier(set.image).setPositions(set); }
  )
  { toReturn = new OutputType(tableType); }

  [
    "("
    expression = Expression()
    { toReturn.addArg(expression); }  
    (
      ","
      expression = Expression()
      { toReturn.addArg(expression); }
    )*
    ")"
  ]

  (
    "["
    index = Component()
    { toReturn.addIndice(index); }
    "]"
  )*

  < OF >
  type = Component()
  { toReturn.setType(type); }
  { toReturn.setPositions(start, type); }

  [
    LOOKAHEAD( < WEIGHT > Component() )
	< WEIGHT >
    weight = Component()
    { toReturn.setWeight(weight); }
    { toReturn.setEnd(weight); }
  ]

  [
    LOOKAHEAD( < FORMAT > "(" ExprList() ")" )
    < FORMAT >
    "("
    ExprList()
    end = ")"
    { toReturn.setEnd(end); }
  ]

  { return toReturn; }
}

// ExprList = Expression {',' Expression }.
ArrayList<Expression> ExprList() :
{
  ArrayList<Expression> toReturn = new ArrayList<Expression>();
  Expression expression;
}
{
  expression = Expression()
  { toReturn.add(expression); }
  (
    ","
    expression = Expression()
    { toReturn.add(expression); }
  )*
  { return toReturn; }
}

// FunctionType = 'function' '(' [ParameterList] ')' [ResultSpec].
// ParameterList = Parameter {',' Parameter}.
// Parameter = identifier ':' Type.
// ResultSpec = ':' Type.
FunctionType FunctionType() :
{
  Token start;
  Token end;
  FunctionType toReturn = new FunctionType();
  Identifier parameter;
  AbstractType type;
}
{
  start = < FUNCTION >
  "("
  [
    parameter = Identifier()
    ":"
    type = Type()
    { toReturn.addArg(new Component(parameter, type)); }

    (
      ","
      parameter = Identifier()
      ":"
      type = Type()
      { toReturn.addArg(new Component(parameter, type)); }
    )*
  ]
  end = ")"
  { toReturn.setPositions(start, end); }

  [
    ":"
    type = Type()
    { toReturn.setType(type); }
    { toReturn.setEnd(type); }
  ]

  { return toReturn; }
}

// VisitorType = 'visitor'.
VisitorType VisitorType() :
{
  Token start;
}
{
  start = < VISITOR >
  { return new VisitorType().setPositions(start); }
}

// Statement =
//   Assignment | Block | BreakStatement | ContinueStatement | DoStatement |
//   EmitStatement | ExprStatement | ForStatement | IfStatement | ResultStatement |
//   ReturnStatement | SwitchStatement | WhenStatement | WhileStatement.
Statement Statement() :
{
  Statement toReturn;
}
{
  (
    LOOKAHEAD( Assignment() )
    toReturn = Assignment()
  |
    LOOKAHEAD( Block() )
    toReturn = Block()
  |
    toReturn = BreakStatement()
  |
    toReturn = ContinueStatement()
  |
    toReturn = DoStatement()
  |
    LOOKAHEAD( EmitStatement() )
    toReturn = EmitStatement()
  |
    toReturn = ExprStatement()
  |
    toReturn = ForStatement()
  |
    toReturn = IfStatement()
  |
    toReturn = ResultStatement()
  |
    toReturn = ReturnStatement()
  |
    toReturn = SwitchStatement()
  |
    toReturn = ForeachStatement()
  |
    toReturn = IfAllStatement()
  |
    toReturn = ExistsStatement()
  |
    toReturn = WhileStatement()
  |
    toReturn = VisitStatement()
  |
    toReturn = StopStatement()
  |
    toReturn = EmptyStatement()
  )
  { return toReturn; }
}

// EmptyStatement = ';'.
Block EmptyStatement() :
{
  Token start;
}
{
  start = < SEMICOLON >
  { return new Block().setPositions(start, start); }
}

// Assignment = Factor '=' Expression ';'.
AssignmentStatement Assignment() :
{
  Token end;
  Factor factor;
  Expression expression;
}
{
  factor = Factor()
  "="
  expression = Expression()
  end = < SEMICOLON >
  { return new AssignmentStatement(factor, expression).setPositions(factor, end); }
}

// Block = '{' { Declaration | Statement } '}'.
Block Block() :
{
  Token start;
  Token end;
  Block toReturn = new Block();
  Statement statement;
}
{
  start = "{"
  (
    (
      LOOKAHEAD( Declaration() )
      statement = Declaration()
    |
      statement = Statement()
    )
    { toReturn.addStatement(statement); }
  )*
  end = "}"
  { return toReturn.setPositions(start, end); }
}

// BreakStatement = 'break'.
BreakStatement BreakStatement() :
{
  Token start;
  Token end;
}
{
  start = < BREAK >
  end = < SEMICOLON >
  { return new BreakStatement().setPositions(start, end); }
}

// ContinueStatement = 'continue'.
ContinueStatement ContinueStatement() :
{
  Token start;
  Token end;
}
{
  start = < CONTINUE >
  end = < SEMICOLON >
  { return new ContinueStatement().setPositions(start, end); }
}

// DoStatement = 'do' Statement 'while' '(' Expression ')' ';'.
DoStatement DoStatement() :
{
  Token start;
  Token end;
  Statement statement;
  Expression expression;
}
{
  start = < DO >
  statement = Statement()
  < WHILE >
  "("
  expression = Expression()
  ")"
  end = < SEMICOLON >
  { return new DoStatement(expression, statement).setPositions(start, end); }
}


// EmitStatement = OutputDesignator '<<' Expression ['weight' Expression] ';'.
// OutputDesignator = var_name {'[' Expression ']'}.
EmitStatement EmitStatement() :
{
  Token end;
  EmitStatement toReturn;
  Identifier varName;
  Expression expression;
  Expression value;
  Expression weight;
}
{
  varName = Identifier()
  { toReturn = new EmitStatement(varName); }

  (
    "["
    expression = Expression()
    { toReturn.addIndice(expression); }
    "]"
  )*

  "<<"

  value = Expression()
  { toReturn.setValue(value); }

  [
	< WEIGHT >
    weight = Expression()
    { toReturn.setWeight(weight); }
  ]

  end = < SEMICOLON >
  { return toReturn.setPositions(varName, end); }
}

// ForStatement =
//   'for' '(' [ForDeclExpr] ';' [Expression] ';' [ForDeclExpr] ')' Statement.
// ForDeclExpr = Declaration | ExprStatement.
ForStatement ForStatement() :
{
  Token start;
  Statement initialize = null;
  Expression expression = null;
  Statement update = null;
  Statement statement;
}
{
  start = < FOR >
  "("
  [
    (
      LOOKAHEAD( ForVarDecl() )
      initialize = ForVarDecl()
    |
      initialize = ForExprStatement()
    )
  ]
  < SEMICOLON >

  [
    expression = Expression()
  ]
  < SEMICOLON >

  [
    (
      LOOKAHEAD( ForVarDecl() )
      update = ForVarDecl()
    |
      update = ForExprStatement()
    )
  ]
  ")"

  statement = Statement()
  { return new ForStatement(initialize, expression, update, statement).setPositions(start, statement); }
}

// ForVarDecl ::= identifier “:” [Type] [“=” Expression | Block]
VarDeclStatement ForVarDecl() :
{
  Identifier identifier;
  AbstractType type = null;
  Expression initializer = null;
}
{
  identifier = Identifier()
  ":"
  [
    LOOKAHEAD( Type() )
    type = Type()
  ]
  [
    "="
    initializer = Expression()
  ]
  { return new VarDeclStatement(identifier, type, initializer).setPositions(identifier, type, initializer); }
}

// ForExprStatement ::= Expression [“++” | “--”]
Statement ForExprStatement() :
{
  Expression expression;
  Token operation = null;
}
{
  expression = Expression()
  [
    (
      operation = "++"
    |
      operation = "--"
    )
    { return new PostfixStatement(expression, operation.image).setPositions(expression, operation); }
  ]
  { return new ExprStatement(expression).setPositions(expression); }
}

// ExprStatement ::= Expression [“++” | “--”] ';'
Statement ExprStatement() :
{
  Token end;
  Statement toReturn;
}
{
  toReturn = ForExprStatement()
  end = < SEMICOLON >
  { return toReturn.setPositions(toReturn, end); }
}

// IfStatement = 'if' '(' Expression ')' Statement ['else' Statement].
IfStatement IfStatement() :
{
  Token start;
  Expression condition;
  Statement ifBody;
  Statement elseBody;
}
{
  start = < IF >
  "("
  condition = Expression()
  ")"

  ifBody = Statement()

  [
    LOOKAHEAD( 1 )
	< ELSE >
    elseBody = Statement()
    { return new IfStatement(condition, ifBody, elseBody).setPositions(start, elseBody); }
  ]

  { return new IfStatement(condition, ifBody).setPositions(start, ifBody); }
}

// ResultStatement = 'result' Expression.
ResultStatement ResultStatement() :
{
  Token start;
  Token end;
  Expression expression;
}
{
  start = < RESULT >
  expression = Expression()
  end = < SEMICOLON >
  { return new ResultStatement(expression).setPositions(start, end); }
}

// ReturnStatement = 'return' [ Expression ].
ReturnStatement ReturnStatement() :
{
  Token start;
  Token end;
  Expression expression = null;
}
{
  start = < RETURN >
  [
    expression = Expression()
  ]
  end = < SEMICOLON >
  { return new ReturnStatement(expression).setPositions(start, end); }
}

// SwitchStatement = 'switch' '(' Expression ')' '{' { Case } Default '}'.
// Case = 'case' CaseLabelList ':' StatementList.
// CaseLabelList = Expression {',' Expression}.
// StatementList = Statement { Statement }.
// Default = 'default' ':' StatementList.
SwitchStatement SwitchStatement() :
{
  Token start;
  Token end;
  Token caseStart;
  SwitchStatement toReturn;
  SwitchCase swcase;
  Block body;
  Expression condition;
  Expression expression;
  Statement statement;
}
{
  start = < SWITCH >
  "("
  condition = Expression()
  ")"
  { toReturn = new SwitchStatement(condition); }

  "{"
  (
    {
      body = new Block();
      swcase = new SwitchCase(false, body);
      toReturn.addCase(swcase);
    }
	caseStart = < CASE >
    expression = Expression()
    { swcase.addCase(expression); }
    (
      ","
      expression = Expression()
      { swcase.addCase(expression); }
    )*
    ":"

    statement = Statement()
    { body.addStatement(statement); }
    (
      statement = Statement()
      { body.addStatement(statement); }
    )*
    { swcase.setPositions(caseStart, statement); }
  )*

  caseStart = < DEFAULT_ >
  ":"
  {
    body = new Block();
    swcase = new SwitchCase(true, body);
    toReturn.setDefault(swcase);
  }
  statement = Statement()
  { body.addStatement(statement); }
  (
    statement = Statement()
    { body.addStatement(statement); }
  )*
  { swcase.setPositions(caseStart, statement); }

  end = "}"
  { return toReturn.setPositions(start, end); }
}

ForeachStatement ForeachStatement() :
{
  Token start;
  Identifier id;
  AbstractType type;
  Expression expression;
  Statement statement;
}
{
  start = < FOREACH >
  "("
  id = Identifier()
  ":"
  type = Type()
  < SEMICOLON >
  expression = Expression()
  ")"
  statement = Statement()
  { return new ForeachStatement(new Component(id, type).setPositions(id, type), expression, statement).setPositions(start, statement); }
}

IfAllStatement IfAllStatement() :
{
  Token start;
  Identifier id;
  AbstractType type;
  Expression expression;
  Statement statement;
}
{
  start = < IFALL >
  "("
  id = Identifier()
  ":"
  type = Type()
  < SEMICOLON >
  expression = Expression()
  ")"
  statement = Statement()
  { return new IfAllStatement(new Component(id, type).setPositions(id, type), expression, statement).setPositions(start, statement); }
}

ExistsStatement ExistsStatement() :
{
  Token start;
  Identifier id;
  AbstractType type;
  Expression expression;
  Statement statement;
}
{
  start = < EXISTS >
  "("
  id = Identifier()
  ":"
  type = Type()
  < SEMICOLON >
  expression = Expression()
  ")"
  statement = Statement()
  { return new ExistsStatement(new Component(id, type).setPositions(id, type), expression, statement).setPositions(start, statement); }
}

// WhileStatement = 'while' '(' Expression ')' Statement.
WhileStatement WhileStatement() :
{
  Token start;
  Expression condition;
  Statement body;
}
{
  start = < WHILE >
  "("
  condition = Expression()
  ")"
  body = Statement()
  { return new WhileStatement(condition, body).setPositions(start, body); }
}

// VisitStatement = ('before' | 'after') (var_name ":" type_name | (Identifier {"," Identifier})) '->' Statement.
VisitStatement VisitStatement() :
{
  Token start;
  VisitStatement toReturn;
  Identifier typeName;
  Identifier id1;
  Identifier id2;
  Statement statement;
}
{
  (
    start = < BEFORE >
    { toReturn = new VisitStatement(true); }
  |
    start = < AFTER >
    { toReturn = new VisitStatement(false); }
  )
  (
    LOOKAHEAD( Identifier() ":" )
    id1 = Identifier()
    ":"
    typeName = Identifier()
    { toReturn.setComponent(new Component(id1, typeName).setPositions(id1, typeName)); }
  |
    id1 = Identifier()
    { toReturn.addId(id1); }
    (
      ","
      id2 = Identifier()
      { toReturn.addId(id2); }
    )*
  |
    < WILDCARD >
    { toReturn.setWildcard(true); }
  )
  "->"
  (
    LOOKAHEAD( Declaration() )
    toAdd = Declaration()
  |
    toAdd = Statement()
  )
  { toReturn.setBody(statement); }
  { return toReturn.setPositions(start, statement); }
}

// StopStatement = ';'.
StopStatement StopStatement() :
{
  Token start;
  Token end;
}
{
  start = < STOP >
  end = < SEMICOLON >
  { return new StopStatement().setPositions(start, end); }
}

// Expression = Conjunction {('||' | 'or') Conjunction}.
Expression Expression() :
{
  Expression toReturn;
  Conjunction lhs;
  Conjunction rhs = null;
}
{
  lhs = Conjunction()
  { toReturn = new Expression(lhs); }
  (
    LOOKAHEAD( ( "||" | < OR > ) Conjunction() )
    (
      (
        "||"
      |
        < OR >
      )
    )
    rhs = Conjunction()
    { toReturn.addRhs(rhs); }
  )*
  { return toReturn.setPositions(lhs, rhs); }
}

// Conjunction = Comparison {('&&' | 'and') Comparison}.
Conjunction Conjunction() :
{
  Conjunction toReturn;
  Comparison lhs;
  Comparison rhs = null;
}
{
  lhs = Comparison()
  { toReturn = new Conjunction(lhs); }
  (
    (
      (
        "&&"
      |
        < AND >
      )
      
    )
    rhs = Comparison()
    { toReturn.addRhs(rhs); }
  )*
  { return toReturn.setPositions(lhs, rhs); }
}


// Comparison = SimpleExpr [relation SimpleExpr].
// relation = '==' | '!=' | '<' | '<=' | '>' | '>='.
Comparison Comparison() :
{
  Comparison toReturn;
  SimpleExpr lhs;
  SimpleExpr rhs;
  Token operation;
}
{
  lhs = SimpleExpr()
  [
    (
      operation = "=="
    |
      operation = "!="
    |
      operation = "<"
    |
      operation = "<="
    |
      operation = ">"
    |
      operation = ">="
    )
    rhs = SimpleExpr()
    { return new Comparison(lhs, operation.image, rhs).setPositions(lhs, rhs); }
  ]
  { return new Comparison(lhs).setPositions(lhs); }
}

// SimpleExpr = Term {add_operator Term}.
// add_operator = '+' | '-' | '|' | '^'.
SimpleExpr SimpleExpr() :
{
  Term lhs;
  Term rhs = null;
  Token operation;
  SimpleExpr toReturn;
}
{
  lhs = Term()
  { toReturn = new SimpleExpr(lhs); }
  (
    (
      operation = "+"
    |
      operation = "-"
    |
      operation =  "|"
    |
      operation = "^"
    )
    { toReturn.addOp(operation.image); }

    rhs = Term()
    { toReturn.addRhs(rhs); }
  )*
  { return toReturn.setPositions(lhs, rhs); }
}

// Term = Factor {mul_operator Factor}.
// mul_operator = '*' | '/' | '%' | '<<' | '>>' | '&'.
Term Term() :
{
  Term toReturn;
  Factor lhs;
  Factor rhs = null;
  Token operation;
}
{
  lhs = Factor()
  { toReturn = new Term(lhs); }
  (
    (
      operation = "*"
    |
      operation = "/"
    |
      operation = "%"
    |
      operation = "<<"
    |
      operation = ">>"
    |
      operation = "&"
    )
    { toReturn.addOp(operation.image); }

    rhs = Factor()
    { toReturn.addRhs(rhs); }
  )*
  { return toReturn.setPositions(lhs, rhs); }
}

// Factor = Operand { Selector | Index | Call }.
Factor Factor() :
{
  Factor toReturn;
  Operand operand;
  Node toAdd = null;
}
{
  operand = Operand()
  { toReturn = new Factor(operand); }
  (
    LOOKAHEAD( 2 )
    (
      toAdd = Selector()
    |
      toAdd = Index()
    |
      toAdd = Call()
    )
    { toReturn.addOp(toAdd); }
  )*
  { return toReturn.setPositions(operand, toAdd); }
}

// Selector = '.' field_name.
// field_name = identifier.
Selector Selector() :
{
  Token start;
  Identifier id;
}
{
  start = "."
  id = Identifier()
  { return new Selector(id).setPositions(start, id); }
}

// Index = '[' Expression [':' Expression] ']'.
Index Index() :
{
  Token first;
  Token last;
  Expression start;
  Expression end = null;
}
{
  first = "["
  start = Expression()
  [
    ":"
    end = Expression()
  ]
  last = "]"
  { return new Index(start, end).setPositions(first, last); }
}

// Call = '(' ArgumentList ')'.
Call Call() :
{
  Token start;
  Token end;
  Call toReturn = new Call();
  Expression expression;
}
{
  start = "("
  [
    expression = Expression()
    { toReturn.addArg(expression); }

    (
      ","
      expression = Expression()
      { toReturn.addArg(expression); }
    )*
  ]
  end = ")"
  { return toReturn.setPositions(start, end); }
}

// Operand =
//   identifier | literal | Composite | Function | unary_operator Factor |
//   '$' | StatementExpr | '(' Expression ')'.
// unary_operator = '+' | '-' | '~' | '!' | 'not'.
Operand Operand() :
{
  Token start;
  Token end;
  Operand operand = null;
  Token operation;
  Expression expression;
  Factor factor;
}
{
  (
    LOOKAHEAD( Identifier() )
    operand = Identifier()
  |
    operand = StringLiteral()
  |
    operand = CharLiteral()
  |
    operand = TimeLiteral()
  |
    operand = IntegerLiteral()
  |
    operand = FloatLiteral()
  |
    LOOKAHEAD( Composite() )
    operand = Composite()
  |
    operand = VisitorExpr()
  |
    operand = Function()
  |
      (
        operation = "+"
      |
        operation = "-"
      |
        operation = "~"
      |
        operation = "!"
      |
        operation = < NOT >
      )
      factor = Factor()
      { return new UnaryFactor(operation.image, factor).setPositions(operation, factor); }
  |
    < DOLLAR >
  |
    operand = StatementExpr()
  |
    start = "("
    expression = Expression()
    end = ")"
    { return new ParenExpression(expression).setPositions(start, end); }
  )
  { return operand; }
}

FunctionExpression Function() :
{
  FunctionType functionType;
  Block block;
}
{
  functionType = FunctionType()
  block = Block()
  { return new FunctionExpression(functionType, block).setPositions(functionType, block); }
}

// Composite = '{' [ExprList | PairList | ':'] '}'.
Composite Composite() :
{
  Token start;
  Token end;
  Composite toReturn = new Composite();
  Pair p;
  Expression e;
}
{
  start = "{"
  [
    (
      LOOKAHEAD( Pair() )
      p = Pair()
      { toReturn.addPair(p); }

      (
        ","
        p = Pair()
        { toReturn.addPair(p); }
      )*
    |
      e = Expression()
      { toReturn.addExpr(e); }

      (
        ","
        e = Expression()
        { toReturn.addExpr(e); }
      )*
    |
      ":"
      { toReturn.setEmpty(true); }
    )
  ]
  end = "}"
  { return toReturn.setPositions(start, end); }
}

// Pair = Expression ':' Expression.
Pair Pair() :
{
  Expression lhs;
  Expression rhs;
}
{
  lhs = Expression()
  ":"
  rhs = Expression()
  { return new Pair(lhs, rhs).setPositions(lhs, rhs); }
}

// VisitorExpr = VisitorType Block.
VisitorExpression VisitorExpr() :
{
  VisitorType visitor;
  Block body;
}
{
  visitor = VisitorType()
  body = Block()
  { return new VisitorExpression(visitor, body).setPositions(visitor, body); }
}

// StatementExpr = '?' Block .
StatementExpr StatementExpr() :
{
  Token first;
  Block block;
}
{
  first = "?"
  block = Block()
  { return new StatementExpr(block).setPositions(first, block); }
}

// identifier = letter {letter | '_' | digit}.
// letter = 'A' .. 'Z' | 'a' .. 'z'.
// digit = '0' .. '9'.
Identifier Identifier() :
{
  Token identifier;
}
{
  (
    identifier = < IDENTIFIER >
  |
    identifier = < FORMAT >
  )
  { return new Identifier(identifier.image).setPositions(identifier); }
}

// integer = ['-'] (binary_int | octal_int | decimal_int | hexadecimal_int).
// binary_int = '0' ('B' | 'b') bin_digit {bin_digit}.
// octal_int = '0' oct_digit {oct_digit}.
// decimal_int = dec_digit {dec_digit}.
// hexadecimal_int = '0' ('X' | 'x') hex_digit {hex_digit}.
// bin_digit = '0' .. '1'.
// oct_digit = '0' .. '7'.
// dec_digit = '0' .. '9'.
// hex_digit = '0' .. '9' | 'A' .. 'F' | 'a' .. 'f'.
IntegerLiteral IntegerLiteral() :
{
  Token integerLiteral;
}
{
  integerLiteral = < INTEGER_LITERAL >
  { return new IntegerLiteral(integerLiteral.image).setPositions(integerLiteral); }
}

// floating_point = ['-'] [integer_part]['.' [fraction_part]] [scale_factor].
// 
// integer_part = decimal_int.
// fraction_part = decimal_int.
// scale_factor = ('E' | 'e') ['+'|'-'] exponent.
// exponent = decimal_int.
FloatLiteral FloatLiteral() :
{
  Token floatingPoint;
}
{
  floatingPoint = < FLOATING_POINT_LITERAL >
  { return new FloatLiteral(floatingPoint.image).setPositions(floatingPoint); }
}

// char = ''' character '''.
// character = ordinary_character | escaped_character.
// escaped_character =
//   '\' oct_digit [oct_digit [oct_digit]] |
//   '\' 'x' hex_digit {hex_digit} |
//   '\' 'u' hex_digit hex_digit hex_digit hex_digit |
//   '\' 'U' hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit |
//   '\' ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\' | '"') |
//   '\' ordinary_character.
CharLiteral CharLiteral() :
{
  Token character;
}
{
  character = < CHARACTER_LITERAL >
  { return new CharLiteral(character.image).setPositions(character); }
}

// string = '"' {character} '"' | '`' {character} '`'.
StringLiteral StringLiteral() :
{
  Token str;
}
{
  (
    str = < STRING_LITERAL >
    { return new StringLiteral(false, str.image).setPositions(str); }
  |
    str = < REGEX_LITERAL >
    { return new StringLiteral(true, str.image).setPositions(str); }
  )
}

// time = integer ('T' | 't') | 'T' string.
TimeLiteral TimeLiteral() :
{
  Token time;
}
{
  time = < TIME_LITERAL >
  { return new TimeLiteral(time.image).setPositions(time); }
}
