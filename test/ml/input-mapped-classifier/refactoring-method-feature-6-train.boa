
# -------------- classifier - multiclassclassifier -------------- 
# Application: refactoring-prone method classifier
# --------------------------------------------------- 
# Input: method-level metrics of a class
# Output: if the method is refactoring-prone.
type L = enum { y = "refactoring-prone", n = "not-refactoring-prone" };
type T = {
	added: int, 
	deleted: int, 
	modified: int,
	changes: int,
	contributors: set of string,
	refactored: bool
};

p: Project = input;
imc: output inputmappedclassifier(
	"-s 75 "
	 + " -W weka.classifiers.rules.OneR"
	 + " -W weka.classifiers.rules.ZeroR"
	 + " -W weka.classifiers.rules.JRip"
	 + " -W weka.classifiers.bayes.NaiveBayes"
	 + " -W weka.classifiers.bayes.BayesNet"
) of {int, int, int, int, int, int, L};

method_map: map[string] of T;
cr := p.code_repositories[0];
class_queue: queue of Declaration;

revision_filter := function(r: Revision) : bool {
	# only consider not merged commits
	if (len(r.parents) == 1)
		return false;
	return true;
};

file_filter := function(cf: ChangedFile) : bool {
	# only consider the modified Java files
	if (isjava(cf) && cf.change == ChangeKind.MODIFIED)
		return false;
	return true;
};

decl_filter := function(d: Declaration) : bool {
	# ignore non-class declaration
	if (d.kind != TypeKind.CLASS)
		return true;
	return false;
};

init_class_queue := function() : queue of Declaration { 
	tmp: queue of Declaration;
	res := class_queue;
	class_queue = tmp;
	return res;
};

class_collector := visitor {
	before d : Declaration -> {
		if (!decl_filter(d)) {
			offer(class_queue, d);
			foreach (i: int; d.nested_declarations[i])
				visit(d.nested_declarations[i]);
		}
		stop;
	}
};

new_tuple := function() : T {
	tmp1: set of string;
	tmp2: set of string;
	t: T = { 0, 0, 0, 0, tmp1, false };
	return t;
};

changed_loc := function(prev: Method, cur: Method, t: T) {
	diff := 0;
	visit(prev, visitor { before s : Statement -> diff++; });
	visit(cur, visitor { before s : Statement -> diff--; });
	if (diff > 0)
		t.added = t.added + diff;
	else if (diff < 0)
		t.deleted = t.deleted + diff * -1;
	else
		t.modified = t.modified + 1;
};

is_refactoring_revision := function(r: Revision) : bool {
	msg := lowercase(r.log);
	patterns := { "refactor", "move", "extract", "rename", "pull up", "push down" };
	foreach (i: int; patterns[i])
		if (strfind(patterns[i], msg) > -1)
			return true;
	return false;
};

get_method := function(cf: ChangedFile, sig: string) : Method {
	m: Method;
	found := false;
	visit(cf, visitor { 
		before d : Declaration -> {
			if (found)
				stop;
			foreach (i: int; d.nested_declarations[i])
				visit(d.nested_declarations[i]);
			exists (i: int; (d.fully_qualified_name + " " + signature(d.methods[i])) == sig) {
				m = d.methods[i];
				found = true;
			}
			stop;
		}
	});
	return m;
};

visit(p, visitor {
	before r : Revision -> {
		if (revision_filter(r))
			stop;
		contributor := r.committer.username;
		refactor := false;
		if (is_refactoring_revision(r))
			refactor = true;
		foreach (i: int; !file_filter(r.files[i])) {
			current_file := r.files[i];
			previous_file := get_previous_file(cr, r, current_file);
			if (!def(previous_file))
				continue;
			visit(current_file, class_collector);
			cur := init_class_queue();
			visit(previous_file, class_collector);
			prev := init_class_queue();

			sigs := modified_methods(prev, cur);
			foreach (j: int; sigs[j]) {
				sig := current_file.name + " " + sigs[j];
				if (!haskey(method_map, sig))
					method_map[sig] = new_tuple();
				
				t := method_map[sig];
				t.changes = t.changes + 1;
				add(t.contributors, contributor);
				changed_loc(get_method(previous_file, sigs[j]), get_method(current_file, sigs[j]), t);
				if (refactor)
					t.refactored = true;
			}
		}
		stop;
	}
	after cr : CodeRepository -> {
		snapshot := getsnapshot(cr);
		foreach (i: int; isjava(snapshot[i])) {
			file := snapshot[i];
			visit(file, class_collector);
			classes := values(init_class_queue());
			foreach (j: int; classes[j]) {
				decl := classes[j];
				foreach (k: int; decl.methods[k]) {
					m := decl.methods[k];
					sig := file.name + " " + decl.fully_qualified_name + " " + signature(m);
					
					loc := 0;
					visit(m, visitor { before s : Statement -> loc++; });
					
					label: L = L.n;
					if (haskey(method_map, sig)) {
						t := method_map[sig];
						if (t.refactored)
							label = L.y;
						imc << { 
							loc, t.added, t.deleted, t.modified, 
							t.changes, len(t.contributors),
							label 
						};
					} else {
						imc << { loc, 1, 0, 0, 0, 1, label };
					}
				}
			}
		}
	}
});