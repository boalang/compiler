# Counting the 10 most used programming languages
p: Project = input;
counts: output top(10) of string weight int;
astCount: int = 0;
type sol = {eigenvals: array of float, eigenvectors: array of array of float};
type optimizedfv = {vectormult: array of array of float, featureMeans: array of float, totalInstances: int};

mapperLocalTotal: array of float;
mapperLocalTotal = new(mapperLocalTotal, 4, 0.0);
mapperLocalFeature : array of array of float;
mapperLocalFeature = new(mapperLocalFeature, 4, mapperLocalTotal);
mapperLocalCounter: int = 0;


pca:= function(vals: array of optimizedfv): sol {
     parta :array of array of float = vals[0].vectormult;
     meansOfFeature: array of float = multiply(vals[0].featureMeans, vals[0].totalInstances);
     accumultedInstances: int = vals[0].totalInstances;

     for(i:int = 1; i < len(vals); i++) {
         parta = matrixsum(parta, vals[i].vectormult);
         tempFeatures: array of float = multiply(vals[i].featureMeans, vals[i].totalInstances);
         meansOfFeature = matrixsum(meansOfFeature, tempFeatures);
         accumultedInstances = accumultedInstances + vals[i].totalInstances;
     }

     # adjust means now
     meansOfFeature[0] = meansOfFeature[0] / accumultedInstances;
     meansOfFeature[1] = meansOfFeature[1] / accumultedInstances;
     meansOfFeature[2] = meansOfFeature[2] / accumultedInstances;
     meansOfFeature[3] = meansOfFeature[3] / accumultedInstances;

     partb : array of array of float = multiply(vector(meansOfFeature), meansOfFeature);

     cov := matrixsubstract(parta, partb);
     eigens: array of float = eigenvalsReal(cov);
     #result : fv = {eigens[0], eigens[1], eigens[2], eigens[3]};
     result : sol = {eigens, eigenvectors(cov)};
     return result;
};


pcsAgg: output pca of optimizedfv;

visit(p, visitor {
	# only look at the latest snapshot
	before n: CodeRepository -> {
		snapshot := getsnapshot(n);
		foreach (i: int; def(snapshot[i]))
			visit(snapshot[i]);
		stop;
	}
	before node: Declaration -> {
		if (node.kind == TypeKind.CLASS) {
			public_ele : float = 0.0;
			protected_ele : float = 0.0;
			private_ele : float = 0.0;
			other: float = 0.0;
			foreach (i: int; def(node.methods[i])) {
			    if(has_modifier_public(node.methods[i])) {
                    public_ele = public_ele + 1;
			    } else if(has_modifier_private(node.methods[i])) {
                    private_ele = private_ele + 1;
                } else if(has_modifier_protected(node.methods[i])) {
                    protected_ele = protected_ele + 1;
                } else {
                   other = other + 1;
                }
			}

			foreach (i: int; def(node.fields[i])) {
			    if(has_modifier_public(node.fields[i])) {
                    public_ele = public_ele + 1;
			    } else if(has_modifier_private(node.fields[i])) {
                    private_ele = private_ele + 1;
                } else if(has_modifier_protected(node.fields[i])) {
                    protected_ele = protected_ele + 1;
                }else {
                    other = other + 1;
                }
			}

			meanPart : array of float = {public_ele, private_ele, protected_ele, other};
			mapperLocalFeature = matrixsum(mapperLocalFeature, multiply(vector(meanPart), meanPart));
			mapperLocalTotal[0] = mapperLocalTotal[0] + public_ele;
            mapperLocalTotal[1] = mapperLocalTotal[1] + private_ele;
            mapperLocalTotal[2] = mapperLocalTotal[2] + protected_ele;
            mapperLocalTotal[3] = mapperLocalTotal[3] + other;
            mapperLocalCounter = mapperLocalCounter + 1;
		}
	}
});

mapperLocalTotal[0] = mapperLocalTotal[0] / mapperLocalCounter;
mapperLocalTotal[1] = mapperLocalTotal[1] / mapperLocalCounter;
mapperLocalTotal[2] = mapperLocalTotal[2] / mapperLocalCounter;
mapperLocalTotal[3] = mapperLocalTotal[3] / mapperLocalCounter;

feature1: optimizedfv = {mapperLocalFeature, mapperLocalTotal, mapperLocalCounter};
pcsAgg << feature1;